# Документация: рациональные числа (`Num`), матрицы (`Matrix`) и генерация Typst‑скриптов (`Script`)

## `Num`

Модуль реализует рациональные числа в виде дробей с целыми числителями и знаменателями и гарантирует, что каждое число хранится в несократимом виде, а знаменатель всегда положителен.

### Тип `Num`

```go
type Num struct {
    a int // числитель
    b int // знаменатель (b != 0, b > 0 после нормализации)
}
```

#### Создание

```go
func NewNum(a, b int) Num
```

Создаёт новое рациональное число `a/b`.

- Если `b == 0`, функция вызывает `panic("denominator cannot be zero")`.
- Результат всегда нормализуется:
  - дробь сокращается на НОД,
  - знаменатель приводится к положительному (знак переносится в числитель).

Примеры:

```go
x := NewNum(2, 4)   // хранится как 1/2
y := NewNum(-2, -4) // хранится как 1/2
z := NewNum(3, -6)  // хранится как -1/2
```

#### Методы вывода

```go
func (n Num) Print()
func (n Num) Println()
func (n Num) String() string
```

- `Print` — печатает число без перевода строки.
- `Println` — печатает число с переводом строки.
- `String` — возвращает строковое представление.

Формат:

- если знаменатель равен `1`, выводится только числитель, например: `3`;
- иначе — `a/b`, например: `3/5`, `-7/2`.

#### Арифметические операции

```go
func Add(a, b Num) Num
func Mul(a, b Num) Num
```

- `Add` — сложение двух рациональных чисел:
  \[
  a = \frac{a_1}{b_1},\ b = \frac{a_2}{b_2}
  \Rightarrow
  Add(a, b) = \frac{a_1 b_2 + a_2 b_1}{b_1 b_2}
  \]
- `Mul` — умножение:
  \[
  Mul(a, b) = \frac{a_1 a_2}{b_1 b_2}
  \]

В обоих случаях результат нормализуется (сокращается, знаменатель делается положительным).

#### Вспомогательные функции (внутренние)

```go
func normalize(n Num) Num
func gcd(a, b int) int
func abs(x int) int
```

- `normalize` — сокращает дробь и нормализует знак.
- `gcd` — НОД двух целых.
- `abs` — модуль числа.

Обычно они используются только внутри модуля.

---

## `Matrix`

Модуль реализует матрицы с элементами типа `Num` и базовые линейно‑алгебраические операции: транспонирование, сложение, умножение, вычисление детерминанта, обратной матрицы, ранга и т.п.

### Тип `Matrix`

```go
type Matrix struct {
    lenm   int     // количество строк
    lenk   int     // количество столбцов
    matrix [][]Num // данные
}
```

- `lenm` — число строк (m).
- `lenk` — число столбцов (k).

#### Создание и инициализация

```go
func New() Matrix
```

Создаёт пустую матрицу `0×0`:

```go
m := New()
```

```go
func FromIntMatrix(IntMat [][]int) Matrix
```

Создаёт матрицу из двумерного среза целых чисел, преобразуя каждое значение в `Num` с знаменателем `1`.

Пример:

```go
ints := [][]int{
    {1, 2},
    {3, 4},
}
A := FromIntMatrix(ints)
// A — матрица 2×2 с элементами 1/1, 2/1, 3/1, 4/1
```

```go
func NewIdentity(n int) Matrix
```

Создаёт единичную матрицу размера `n×n`:

```go
I := NewIdentity(3) // 3×3, единицы на диагонали, нули вне диагонали
```


#### Работа со строками и столбцами

```go
func (m *Matrix) Append(row []Num) error
```

Добавляет строку в конец матрицы.

- Для первой добавленной строки задаётся число столбцов.
- Для последующих строк длина должна совпадать с `lenk`, иначе возвращается `ErrIrregularMatrix`.

---

```go
func (m *Matrix) SwapRows(i, j int)
func (m *Matrix) SwapCols(i, j int)
```

Меняют местами строки `i` и `j` или столбцы `i` и `j` (индексация с нуля).

---

```go
func (m *Matrix) ScaleRow(i int, k Num)
```

Домножает строку `i` на скаляр `k` (поэлементно).

---

```go
func (m *Matrix) AddRow(dst, src int, k Num)
```

Выполняет элементарное преобразование строк:
\[
\text{row}_{dst} \leftarrow \text{row}_{dst} + k \cdot \text{row}_{src}
\]

---

#### Копирование и вывод

```go
func (m Matrix) Copy() Matrix
```

Возвращает глубокую копию матрицы (новый двумерный срез).

---

```go
func (m *Matrix) Print()
func (m *Matrix) String() string
```

- `Print` — выводит матрицу в stdout (по строкам).
- `String` — возвращает строковое представление, подходящее для передачи в Typst `mat(...)`:
  - элементы в строке разделяются `", "`,
  - строки разделяются `";\n"`.

Пример (логический формат):

```text
1, 2/3;
4, 5;
```

---

#### Транспонирование

```go
func (m Matrix) T() Matrix
```

Возвращает транспонированную матрицу (строки ↔ столбцы).

- Если матрица пустая (`lenm == 0` или `lenk == 0`), возвращает пустую матрицу.

---

#### Арифметика матриц

```go
func AddMatrix(a, b Matrix) (Matrix, error)
```

Покомпонентное сложение матриц одинакового размера.

- Требование: `a.lenm == b.lenm` **и** `a.lenk == b.lenk`.
- Возвращает новую матрицу и `nil` при успехе, ошибку при несовпадении размеров.

---

```go
func (m *Matrix) MulMatrixNum(a Num)
```

Умножение матрицы на скаляр `a` (поэлементно, in‑place).

---

```go
func MulMatrix(a, b Matrix) (Matrix, error)
```

Умножение матриц:

\[
C = A \cdot B,\quad
C_{ij} = \sum_{p} A_{ip} \cdot B_{pj}
\]

- Требование: `a.lenk == b.lenm`.
- Размер результата: `a.lenm × b.lenk`.
- При несоответствии размеров возвращает `ErrIrregularMatrix`.

---

#### Детерминант и обратная матрица

```go
func (m Matrix) Det() (Num, error)
```

Вычисляет детерминант квадратной матрицы с помощью модифицированного Гауссова исключения.

- Требование: `lenm == lenk` (квадратная матрица), иначе — ошибка `ErrSquare`.
- При нулевом детерминанте возвращает `0/1` и `nil` (факт вырожденности кодируется значением, а не ошибкой).

---

```go
func (m Matrix) Inverse() (Matrix, error)
```

Вычисляет обратную матрицу методом Гаусса‑Жордана.

- Требование: матрица квадратная.
- При вырожденной матрице (детерминант 0) возвращает ошибку `"matrix is singular"`.
- При успехе возвращает матрицу `M⁻¹`, такую что `M · M⁻¹ = I`.

---

#### Приведение к ступенчатому виду и ранг

```go
func (m Matrix) REF() Matrix
```

Возвращает матрицу в **строчном ступенчатом виде** (Row Echelon Form, REF):

- последовательно выбираются опорные элементы (pivots),
- для каждой опорной строки:
  - строка нормируется так, чтобы pivot был равен 1,
  - все элементы под pivot зануляются.

---

```go
func (m Matrix) RREF() Matrix
```

Возвращает матрицу в **приведённом строчном ступенчатом виде** (Reduced Row Echelon Form, RREF):

- сначала строится `REF`,
- затем для каждого pivot зануляются элементы **над** ним.

---

```go
func (m Matrix) Rank() int
```

Возвращает ранг матрицы — количество ненулевых строк в её `REF`:

- строка считается нулевой, если все элементы в ней имеют числитель `0`.

---

### Пример использования `Matrix`

```go
A := FromIntMatrix([][]int{
    {1, 2},
    {3, 4},
})

B := FromIntMatrix([][]int{
    {5, 6},
    {7, 8},
})

C, err := MulMatrix(A, B)
if err != nil {
    panic(err)
}

detA, err := A.Det()
if err != nil {
    panic(err)
}

invA, err := A.Inverse()
if err != nil {
    fmt.Println("A is singular")
} else {
    fmt.Println("A^{-1}:")
    invA.Print()
}

fmt.Println("rank(A) =", A.Rank())
```

---

## Модуль `script` (тип `Script`)

Модуль отвечает за генерацию Typst‑скрипта, его сохранение в файл и компиляцию в PDF с помощью внешней команды `typst compile`.

### Тип `Script`

```go
type Script struct {
    s    string // накопленная строка скрипта Typst
    path string // относительный путь к .typ-файлу (без каталога outputs/)
}
```

Полное имя файла формируется функцией `WriteToFile` (см. ниже).

### Создание скрипта

```go
func NewScript(nameFile string) Script
```

Создаёт новый объект `Script`.

- `nameFile` — базовое имя файла **без** расширения.
- Внутри сохраняется путь `nameFile + ".typ"` (файл будет размещён в каталоге `outputs`).

Пример:

```go
s := NewScript("example") // будет создан outputs/example.typ и outputs/example.pdf
```

---

### Наполнение скрипта

```go
func (s *Script) Append(text string)
func (s *Script) Appendln(text string)
```

- `Append` — добавляет строку `text` к скрипту без перевода строки.
- `Appendln` — добавляет `text` с завершающим `\n`.

---

#### Добавление матриц в формате Typst

Все функции ниже добавляют в скрипт фрагменты, которые можно использовать в Typst для вывода матриц (через функцию `mat(...)`).

```go
func (s *Script) AddMatrix(m Matrix, name string)
```

Добавляет определение именованной матрицы:

```typst
name = mat( <строковое представление m> )
```

Например, если `name == "A"`, будет сгенерировано:

```typst
A = mat( 1, 2; 
3, 4;
)
```

---

```go
func (s *Script) AddMatrixln(m Matrix, name string)
```

То же, что и `AddMatrix`, но завершает запись переводом строки и `\` (для переноса строки в Typst):

```typst
A = mat( ... )
\
```

Удобно для последовательного вывода шагов преобразований.

---

```go
func (s *Script) AddEqualMatrix(m Matrix)
```

Добавляет к скрипту матрицу без имени, начиная с символа тильды (`~`), что удобно для выравнивания по знаку равенства или тильды в Typst:

```typst
~
mat( <строковое представление m> )
```

Используется, например, для цепочек равенств/преобразований матриц:

```typst
A = mat( ... )
~
mat( ... )
~
mat( ... )
```

---

### Запись скрипта и компиляция в PDF

```go
func (s *Script) WriteToFile() error
```

Выполняет следующие действия:

1. Создаёт (при необходимости) директорию `outputs` с правами `0755`.
2. Определяет пути:
   - `scriptPath` — `outputs/<basename>.typ`,
   - `pdfPath` — `outputs/<basename>.pdf`,
     где `<basename>` — базовое имя `s.path` без директорий.
3. Удаляет существующий PDF (`pdfPath`), если он есть.
4. Создаёт/перезаписывает `.typ`‑файл и записывает в него содержимое `s.s`.
5. Запускает внешнюю команду:

   ```bash
   typst compile scriptPath pdfPath
   ```

   - `Stdout` и `Stderr` команды направляются в стандартный вывод текущего процесса.
   - Если команда завершилась с ошибкой, возвращается ошибка вида `typst compile failed: ...`.

#### Требования и замечания

- Утилита `typst` должна быть установлена и доступна в `PATH`.
- При успешной работе в `outputs/` появляются два файла:
  - `<basename>.typ` — текст скрипта;
  - `<basename>.pdf` — скомпилированный PDF.

---

### Пример использования `Script` совместно с матрицами

```go
func main() {
    // 1. Составляем матрицу
    A := FromIntMatrix([][]int{
        {1, 2},
        {3, 4},
    })

    // 2. Строим её обратную (если существует)
    invA, err := A.Inverse()
    if err != nil {
        fmt.Println("A is singular:", err)
        return
    }

    // 3. Создаём Typst-скрипт
    s := NewScript("matrix-example")

    s.Appendln("#let mat-demo = block[")
    s.AddMatrix(A, "A")
    s.AddMatrixln(invA, "A_inv")
    s.Appendln("]")

    // 4. Пишем файл и компилируем в PDF
    if err := s.WriteToFile(); err != nil {
        fmt.Println("error:", err)
    }
}
```

После запуска в каталоге `outputs/` появятся:

- `output.typ` — Typst‑скрипт,
- `output.pdf` — PDF с выведенными матрицами `A` и `A_inv`.
